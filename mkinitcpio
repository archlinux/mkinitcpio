#!/usr/bin/env bash
# SPDX-License-Identifier: GPL-2.0-only
#
# mkinitcpio - modular tool for building an initramfs images
#

declare -r version=%VERSION%

shopt -s extglob

### globals within mkinitcpio, but not intended to be used by hooks

# needed files/directories
_f_functions=functions
_f_config=mkinitcpio.conf
_d_hooks="$PWD/hooks:/usr/lib/initcpio/hooks:/lib/initcpio/hooks"
_d_install="$PWD/install:/usr/lib/initcpio/install:/lib/initcpio/install"
_d_post="$PWD/post:/usr/lib/initcpio/post:/lib/initcpio/post"
_d_flag_hooks=
_d_flag_install=
_d_flag_post=
_d_firmware=({/usr,}/lib/firmware/updates {/usr,}/lib/firmware)
_d_presets=mkinitcpio.d

# options and runtime data
_optmoduleroot='' _optgenimg=''
_optcompress='' _opttargetdir=''
_optosrelease=''
_optuki='' _optmicrocode=() _optcmdline='' _optsplash='' _optkernelimage='' _optuefistub=''
_optshowautomods=0 _optsavetree=0 _optshowmods=0 _optremove=0
_optquiet=1 _optcolor=1
_optskiphooks=() _optaddhooks=() _hooks=() _optpreset=() _tmpfiles=() _generated=()
declare -A _runhooks _addedmodules _modpaths _autodetect_cache

# export a sane PATH
export PATH='/usr/local/sbin:/usr/local/bin:/usr/bin'

# Sanitize environment further
# GREP_OPTIONS="--color=always" will break everything
# CDPATH can affect cd and pushd
# LIBMOUNT_* options can affect findmnt and other tools
unset GREP_OPTIONS CDPATH "${!LIBMOUNT_@}"

usage() {
    cat <<EOF
mkinitcpio $version
usage: ${0##*/} [options]

  Options:
   -A, --addhooks <hooks>       Add specified hooks, comma separated, to image
   -c, --config <config>        Use alternate config file. (default: /etc/mkinitcpio.conf)
   -g, --generate <path>        Generate cpio image and write to specified path
   -H, --hookhelp <hookname>    Display help for given hook and exit
   -h, --help                   Display this message and exit
   -k, --kernel <kernelver>     Use specified kernel version (default: $(uname -r))
   -L, --listhooks              List all available hooks
   -M, --automods               Display modules found via autodetection
   -n, --nocolor                Disable colorized output messages
   -p, --preset <file>          Build specified preset from /etc/mkinitcpio.d
   -P, --allpresets             Process all preset files in /etc/mkinitcpio.d
   -R, --remove                 Remove specified preset images
                                This option can only be used with either '-p|--presets' or '-P|--allpresets'
   -r, --moduleroot <dir>       Root directory for modules (default: /)
   -S, --skiphooks <hooks>      Skip specified hooks, comma-separated, during build
   -s, --save                   Save build directory. (default: no)
   -d, --generatedir <dir>      Write generated image into <dir>
   -t, --builddir <dir>         Use DIR as the temporary build directory
   -D, --hookdir <dir>          Specify where to look for hooks
   -U, --uki <path>             Build a unified kernel image
   -V, --version                Display version information and exit
   -v, --verbose                Verbose output (default: no)
   -z, --compress <program>     Use an alternate compressor on the image (cat, xz, lz4, zstd)

  Options for unified kernel image (-U, --uki):
   --cmdline <path>             Set kernel command line from file
                                (default: /etc/kernel/cmdline or /proc/cmdline)
   --microcode <path>           Location of microcode
   --osrelease <path>           Include os-release (default: /etc/os-release)
   --splash <path>              Include bitmap splash
   --kernelimage <path>         Kernel image
   --uefistub <path>            Location of UEFI stub loader

EOF
}

version() {
    cat <<EOF
mkinitcpio "$version"
EOF
}

# The function is called from the EXIT trap
# shellcheck disable=SC2317
cleanup() {
    local err="${1:-$?}"

    if (( ${#_tmpfiles[@]} )); then
        rm -f -- "${_tmpfiles[@]}"
    fi
    if [[ -n "$_d_workdir" ]]; then
        # when _optpreset is set, we're in the main loop, not a worker process
        if (( _optsavetree )) && [[ -z ${_optpreset[*]} ]]; then
            printf '%s\n' "${!_autodetect_cache[@]}" >"$_d_workdir/autodetect_modules"
            msg "build directory saved in '%s'" "$_d_workdir"
        else
            rm -rf -- "$_d_workdir"
        fi
    fi

    exit "$err"
}

resolve_kernver() {
    local kernel="$1" arch=''

    if [[ -z "$kernel" ]]; then
        uname -r
        return 0
    fi

    if [[ "${kernel:0:1}" != / ]]; then
        echo "$kernel"
        return 0
    fi

    if [[ ! -e "$kernel" ]]; then
        error "specified kernel image does not exist: '%s'" "$kernel"
        return 1
    fi

    kver "$kernel" && return

    error "invalid kernel specified: '%s'" "$1"

    arch="$(uname -m)"
    if [[ "$arch" != @(i?86|x86_64) ]]; then
        error "kernel version extraction from image not supported for '%s' architecture" "$arch"
        error "there's a chance the generic version extractor may work with a valid uncompressed kernel image"
    fi

    return 1
}

hook_help() {
    local resolved script
    script="$(PATH="$_d_install" type -p "$1")"

    # this will be true for broken symlinks as well
    if [[ -z "$script" ]]; then
        error "Hook '%s' not found" "$1"
        return 1
    fi

    if resolved="$(readlink "$script")" && [[ "${script##*/}" != "${resolved##*/}" ]]; then
        msg "This hook is deprecated. See the '%s' hook" "${resolved##*/}"
        return 0
    fi

    # shellcheck disable=SC1090
    . "$script"
    if ! declare -f help >/dev/null; then
        error "No help for hook $1"
        return 1
    fi

    msg "Help for hook '$1':"
    help

    list_hookpoints "$1"
}

hook_list() {
    local p hook resolved
    local -a paths hooklist depr
    local ss_ordinals=(¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹)

    IFS=: read -ra paths <<<"$_d_install"

    for path in "${paths[@]}"; do
        for hook in "$path"/*; do
            [[ -e "$hook" || -L "$hook" ]] || continue

            # handle deprecated hooks and point to replacement
            if resolved="$(readlink "$hook")" && [[ "${hook##*/}" != "${resolved##*/}" ]]; then
                resolved="${resolved##*/}"

                if ! index_of "$resolved" "${depr[@]}"; then
                    # deprecated hook
                    depr+=("$resolved")
                    _idx=$(( ${#depr[*]} - 1 ))
                fi

                hook+=${ss_ordinals[_idx]}
            fi

            hooklist+=("${hook##*/}")
        done
    done

    msg "Available hooks"
    printf '%s\n' "${hooklist[@]}" | sort -u | column -c"$(tput cols)"

    if (( ${#depr[*]} )); then
        echo
        for p in "${!depr[@]}"; do
            printf $'\'%s\' This hook is deprecated in favor of \'%s\'\n' \
                "${ss_ordinals[p]}" "${depr[p]}"
        done
    fi
}

compute_hookset() {
    local h

    for h in "${HOOKS[@]}" "${_optaddhooks[@]}"; do
        in_array "$h" "${_optskiphooks[@]}" && continue
        _hooks+=("$h")
    done
}

build_image() {
    local out="$1" compressout="$1" compress="$2" errmsg pipestatus

    case "$compress" in
        cat)
            msg "Creating uncompressed initcpio image: '%s'" "$out"
            unset COMPRESSION_OPTIONS
            ;;
        *)
            msg "Creating %s-compressed initcpio image: '%s'" "$compress" "$out"
            ;;&
        xz)
            COMPRESSION_OPTIONS=('-T0' '--check=crc32' "${COMPRESSION_OPTIONS[@]}")
            ;;
        lz4)
            COMPRESSION_OPTIONS=('-l' "${COMPRESSION_OPTIONS[@]}")
            ;;
        zstd)
            COMPRESSION_OPTIONS=('-T0' "${COMPRESSION_OPTIONS[@]}")
            ;;
    esac

    if [[ -f "$out" ]]; then
        local curr_size space_left_on_device

        curr_size="$(stat --format="%s" "$out")"
        space_left_on_device="$(($(stat -f --format="%a*%S" "$out")))"

        # check if there is enough space on the device to write the image to a tempfile, fallback otherwise
        # this assumes that the new image is not more than 1¼ times the size of the old one
        (( $((curr_size + (curr_size/4))) < space_left_on_device )) && compressout="$out".tmp
    fi

    pushd "$BUILDROOT" >/dev/null || return

    # Reproducibility: set all timestamps to 0
    find . -mindepth 1 -execdir touch -hcd "@0" "{}" +

    # If this pipeline changes, |pipeprogs| below needs to be updated as well.
    find . -mindepth 1 -printf '%P\0' \
        | sort -z \
        | LANG=C bsdtar --uid 0 --gid 0 --null -cnf - -T - \
        | LANG=C bsdtar --null -cf - --format=newc @- \
        | $compress "${COMPRESSION_OPTIONS[@]}" >"$compressout"

    pipestatus=("${PIPESTATUS[@]}")
    pipeprogs=('find' 'sort' 'bsdtar (step 1)' 'bsdtar (step 2)' "$compress")

    popd >/dev/null || return

    for (( i = 0; i < ${#pipestatus[*]}; ++i )); do
        if (( pipestatus[i] )); then
            errmsg="${pipeprogs[i]} reported an error"
            break
        fi
    done

    if (( _builderrors )); then
        warning "errors were encountered during the build. The image may not be complete."
    fi

    if [[ -n "$errmsg" ]]; then
        error "Image generation FAILED: '%s'" "$errmsg"
        return 1
    elif (( _builderrors == 0 )); then
        msg "Image generation successful"
    fi

    # sync and rename as we only wrote to a tempfile so far to ensure consistency
    if [[ "$compressout" != "$out" ]]; then
        sync -d -- "$compressout"
        mv -f -- "$compressout" "$out"
    fi
}

build_uki() {
    local out="$1" initramfs="$2" cmdline="$3" osrelease="$4" splash="$5" kernelimg="$6" uefistub="$7" microcode=("${@:8}") errmsg=''
    local -i offset=0 align=0 mask=0
    OBJCOPYARGS=()

    # reproducibility, preserve dates of used files
    OBJCOPYARGS+=(-p)

    msg "Creating unified kernel image: '%s'" "$out"

    if [[ -z "$uefistub" ]]; then
        for stub in {/usr,}/lib/{systemd/boot/efi,gummiboot}/linux{x64,ia32,aa64}.efi.stub; do
            if [[ -f "$stub" ]]; then
                uefistub="$stub"
                msg2 "Using UEFI stub: '%s'" "$uefistub"
                break
            fi
        done
    fi
    if [[ ! -f "$uefistub" ]]; then
        error "UEFI stub '%s' not found" "$uefistub"
        return 1
    fi

    align="$(objdump -p "${uefistub}" | awk '/SectionAlignment/ {print strtonum("0x"$2)}')"
    mask="$((-align))"

    offset="$(objdump -h "${uefistub}" | awk 'NF==7 {size=strtonum("0x"$3); offset=strtonum("0x"$4)} END {print size + offset}')"
    offset="$(((offset & mask) + align))"

    if [[ -z "$osrelease" ]]; then
        if [[ -f "/etc/os-release" ]]; then
            osrelease="/etc/os-release"
        elif [[ -f "/usr/lib/os-release" ]]; then
            osrelease="/usr/lib/os-release"
        fi
        msg2 "Using os-release file: '%s'" "$osrelease"
    fi
    if [[ ! -f "$osrelease" ]]; then
        error "os-release file '%s' not found" "$osrelease"
        return 1
    fi

    OBJCOPYARGS+=(--add-section ".osrel=${osrelease}" --change-section-vma ".osrel=$(printf 0x%x "$offset")")
    offset="$((offset + $(stat -Lc%s "$osrelease")))"
    offset="$(((offset & mask) + align))"

    if [[ -z "$cmdline" ]]; then
        if [[ -f "/etc/kernel/cmdline" ]]; then
            cmdline="/etc/kernel/cmdline"
        elif [[ -f "/usr/lib/kernel/cmdline" ]]; then
            cmdline="/usr/lib/kernel/cmdline"
        else
            warning "Note: /etc/kernel/cmdline does not exist and --cmdline is unset!"
            cmdline="/proc/cmdline"
            warning "Reusing current kernel cmdline from $cmdline"
        fi
        msg2 "Using cmdline file: '%s'" "$cmdline"
    fi
    if [[ ! -f "$cmdline" ]]; then
        error "Kernel cmdline file '%s' not found" "$cmdline"
        return 1
    fi

    cmdline_tmp="$(mktemp -t mkinitcpio.XXXXXX)"
    _tmpfiles+=("$cmdline_tmp")

    printf "%s\n\0" "$(grep -a '^[^#]' "$cmdline" | tr -s '\n' ' ')" >"$cmdline_tmp"

    OBJCOPYARGS+=(--add-section ".cmdline=${cmdline_tmp}" --change-section-vma .cmdline="$(printf 0x%x "$offset")")
    offset="$((offset + $(stat -Lc%s "$cmdline_tmp")))"
    offset="$(((offset & mask) + align))"

    if [[ -n "$splash" ]]; then
        OBJCOPYARGS+=(--add-section ".splash=${splash}" --change-section-vma ".splash=$(printf 0x%x "$offset")")
        offset="$((offset + $(stat -Lc%s "$splash")))"
        offset="$(((offset & mask) + align))"
        msg2 "Using splash image: '%s'" "$splash"
    fi

    if [[ -z "$kernelimg" ]]; then
        # FIXME: fallback to /boot/vmlinuz-linux can probably be removed as
        #   $KERNELIMAGE should point to an image with the correct version
        for img in "$KERNELIMAGE" "/boot/vmlinuz-linux"; do
            if [[ -f "$img" ]]; then
                kernelimg="$img"
                msg2 "Using kernel image: '%s'" "$kernelimg"
                break
            fi
        done
    fi
    if [[ ! -f "$kernelimg" ]]; then
        error "Kernel image '%s' not found" "$kernelimg"
        return 1
    fi

    OBJCOPYARGS+=(--add-section ".linux=${kernelimg}" --change-section-vma ".linux=$(printf 0x%x "$offset")")
    offset="$((offset + $(stat -Lc%s "$kernelimg")))"
    offset="$(((offset & mask) + align))"

    if [[ -z "$initramfs" ]]; then
        error "Initramfs '%s' not found" "$initramfs"
        return 1
    fi

    for image in "${microcode[@]}"; do
        msg2 "Using microcode image: '%s'" "$image"
    done

    initramfs_tmp="$(mktemp -t mkinitcpio.XXXXXX)"
    _tmpfiles+=("$initramfs_tmp")

    cat -- "${microcode[@]}" "$initramfs" >"$initramfs_tmp"

    OBJCOPYARGS+=(--add-section ".initrd=${initramfs_tmp}" --change-section-vma ".initrd=$(printf 0x%x "$offset")")

    objcopy "${OBJCOPYARGS[@]}" "$uefistub" "$out"

    status="$?"
    if (( status )) ; then
        error 'Unified kernel image generation FAILED'
    else
        msg 'Unified kernel image generation successful'
    fi
}

# The function is invoked via `map process_preset`
# shellcheck disable=SC2317
process_preset() (
    local preset="$1" preset_image='' preset_options=''
    local -a preset_mkopts preset_cmd preset_remove_cmd
    if (( MKINITCPIO_PROCESS_PRESET )); then
        error "You appear to be calling a preset from a preset. This is a configuration error."
        exit 1
    fi

    # allow path to preset file, else resolve it in $_d_presets
    if [[ $preset != */* ]]; then
        printf -v preset '%s/%s.preset' "$_d_presets" "$preset"
    fi

    # shellcheck disable=SC1090
    . "$preset" || die "Failed to load preset: '%s'" "$preset"

    (( ! ${#PRESETS[@]} )) && warning "Preset file '%s' is empty or does not contain any presets." "$preset"

    # Use -m and -v options specified earlier
    (( _optquiet )) || preset_mkopts+=(-v)
    (( _optcolor )) || preset_mkopts+=(-n)

    (( _optsavetree )) && preset_mkopts+=(-s)

    ret=0
    for p in "${PRESETS[@]}"; do
        if (( _optremove )); then
            msg "Removing image for preset: $preset: '$p'"
        else
            msg "Building image from preset: $preset: '$p'"
        fi
        preset_cmd=("${preset_mkopts[@]}")
        preset_remove_cmd=()

        preset_kver="${p}_kver"
        if [[ -n "${!preset_kver:-$ALL_kver}" ]]; then
            preset_cmd+=(-k "${!preset_kver:-$ALL_kver}")
        else
            warning "No kernel version specified. Skipping image '%s'" "$p"
            continue
        fi

        preset_config="${p}_config"
        if [[ -n "${!preset_config:-$ALL_config}" ]]; then
            preset_cmd+=(-c "${!preset_config:-$ALL_config}")
        else
            warning "No configuration file specified. Skipping image '%s'" "$p"
            continue
        fi

        preset_uki="${p}_uki"
        if [[ ! -v "${p}_uki" && -v "${p}_efi_image" ]]; then
            preset_uki="${p}_efi_image"
            warning "Deprecated option '%s' found. Update '%s' to use '%s' instead." "${p}_efi_image" "$preset" "${p}_uki"
        fi

        if [[ -n "${!preset_uki}" ]]; then
            preset_cmd+=(-U "${!preset_uki}")
            preset_remove_cmd+=("${!preset_uki}")
        fi

        preset_image="${p}_image"
        if [[ -n "${!preset_image}" ]]; then
            preset_cmd+=(-g "${!preset_image}")
            preset_remove_cmd+=("${!preset_image}")
        elif [[ -z "${!preset_uki}" ]]; then
            warning "No image or UKI specified. Skipping image '%s'" "$p"
            continue
        fi

        preset_options="${p}_options"
        if [[ -n "${!preset_options}" ]]; then
            mapfile -d ' ' -O "${#preset_cmd[@]}" -t preset_cmd < <(
                printf '%s' "${!preset_options}"
            )
        fi

        declare -n preset_microcode="${p}_microcode"
        if [[ -n "${preset_microcode[*]}" || -n "${ALL_microcode[*]}" ]]; then
            mapfile -d '' -O "${#preset_cmd[@]}" -t preset_cmd < <(
                printf -- '--microcode\0%s\0' "${preset_microcode[@]:-${ALL_microcode[@]}}"
            )
        fi

        if (( _optremove )); then
            if (( ${#preset_remove_cmd[*]} )); then
                # we won't be calling mkinitcpio recursively, so no need to set MKINITCPIO_PROCESS_PRESET
                for pr in "${preset_remove_cmd[@]}"; do
                    if [[ ! -f "${pr}" ]]; then
                        warning "Image not found: '%s'" "$pr"
                    elif [[ ! -w "${pr}" ]]; then
                        error "Image not writable: '%s'" "$pr"
                    else
                        rm -f -- "${pr}"
                        msg2 "Removed: '%s'" "$pr"
                        warning "Image not found: '%s'" "$pr"
                    fi
                done
            fi
        else
            preset_cmd+=("${OPTREST[@]}")
            msg2 "${preset_cmd[*]}"
            MKINITCPIO_PROCESS_PRESET=1 "$0" "${preset_cmd[@]}"
        fi
        # shellcheck disable=SC2181
        (( $? )) && ret=1
    done

    exit "$ret"
)

preload_builtin_modules() {
    local modname field value
    local -a path

    # Prime the _addedmodules list with the builtins for this kernel. We prefer
    # the modinfo file if it exists, but this requires a recent enough kernel
    # and kmod>=27.

    if [[ -r $_d_kmoduledir/modules.builtin.modinfo ]]; then
        while IFS=.= read -rd '' modname field value; do
            _addedmodules[${modname//-/_}]=2
            case "$field" in
                alias)
                    _addedmodules["${value//-/_}"]=2
                    ;;
            esac
        done <"$_d_kmoduledir/modules.builtin.modinfo"

    elif [[ -r "$_d_kmoduledir/modules.builtin" ]]; then
        while IFS=/ read -ra path; do
            modname="${path[-1]%.ko}"
            _addedmodules["${modname//-/_}"]=2
        done <"$_d_kmoduledir/modules.builtin"
    fi
}

run_post_hooks() {
    local args=("$@")
    local hook status
    local -i count=0
    local -a paths seen

    IFS=: read -ra paths <<<"$_d_post"

    for path in "${paths[@]}"; do
        for hook in "$path"/*; do
            if [[ ! -e "$hook" ]] || in_array "${hook##*/}" "${seen[@]}"; then
                continue
            fi
            seen+=("${hook##*/}")

            [[ -x "$hook" ]] || continue

            (( count++ )) || msg 'Running post hooks'
            msg2 'Running post hook: [%s]' "${hook##*/}"

            KERNELVERSION="$KERNELVERSION" KERNELDESTINATION="$KERNELDESTINATION" command "$hook" "$KERNELIMAGE" "${args[@]}"
            status="$?"

            if (( status )); then
                error "'%s' failed with exit code %d" "$hook" "$status"
                return 1
            fi
        done
    done

    (( count )) && msg 'Post processing done'
    return 0
}

# shellcheck source=functions
. "$_f_functions"

trap 'cleanup' EXIT

_opt_short='A:c:D:g:H:hk:nLMPp:Rr:S:sd:t:U:Vvz:'
_opt_long=('add:' 'addhooks:' 'config:' 'generate:' 'hookdir': 'hookhelp:' 'help'
           'kernel:' 'listhooks' 'automods' 'moduleroot:' 'nocolor' 'allpresets'
           'preset:' 'remove' 'skiphooks:' 'save' 'generatedir:' 'builddir:' 'version' 'verbose' 'compress:'
           'uki:' 'uefi:' 'microcode:' 'splash:' 'kernelimage:' 'uefistub:' 'cmdline:' 'osrelease:')

parseopts "$_opt_short" "${_opt_long[@]}" -- "$@" || exit 1
set -- "${OPTRET[@]}"
unset _opt_short _opt_long OPTRET

while :; do
    case "$1" in
        # --add remains for backwards compat
        -A | --add | --addhooks)
            shift
            IFS=, read -r -a add <<<"$1"
            _optaddhooks+=("${add[@]}")
            unset add
            ;;
        -c | --config)
            shift
            _f_config="$1"
            ;;
        --cmdline)
            shift
            _optcmdline="$1"
            ;;
        -k | --kernel)
            shift
            KERNELVERSION="$1"
            ;;
        -s | --save)
            _optsavetree=1
            ;;
        -d | --generatedir)
            shift
            _opttargetdir="$1"
            ;;
        -g | --generate)
            shift
            [[ -d "$1" ]] && die 'Invalid image path -- must not be a directory'
            if ! _optgenimg="$(readlink -f "$1")" || [[ ! -e "${_optgenimg%/*}" ]]; then
                die "Unable to write to path: '%s'" "$1"
            fi
            ;;
        -h | --help)
            usage
            exit 0
            ;;
        -V | --version)
            version
            exit 0
            ;;
        -p | --preset)
            shift
            _optpreset+=("$1")
            ;;
        -R | --remove)
            _optremove=1
            ;;
        -n | --nocolor)
            _optcolor=0
            ;;
        --uefi)
            warning 'The --uefi option is deprecated. Use --uki instead.'
            ;&
        -U | --uki)
            shift
            [[ -d "$1" ]] && die "Invalid image path -- must not be a directory"
            if ! _optuki="$(readlink -f "$1")" || [[ ! -e "${_optuki%/*}" ]]; then
                die "Unable to write to path: '%s'" "$1"
            fi
            ;;
        -v | --verbose)
            _optquiet=0
            ;;
        -S | --skiphooks)
            shift
            IFS=, read -r -a skip <<<"$1"
            _optskiphooks+=("${skip[@]}")
            unset skip
            ;;
        -H | --hookhelp)
            shift
            hook_help "$1"
            exit
            ;;
        -L | --listhooks)
            hook_list
            exit 0
            ;;
        --splash)
            shift
            [[ -f "$1" ]] || die 'Invalid file -- must be a file'
            _optsplash="$1"
            ;;
        --kernelimage)
            shift
            _optkernelimage="$1"
            ;;
        --uefistub)
            shift
            _optuefistub="$1"
            ;;
        -M | --automods)
            _optshowautomods=1
            ;;
        --microcode)
            shift
            _optmicrocode+=("$1")
            ;;
        -P | --allpresets)
            _optpreset=("$_d_presets"/*.preset)
            [[ -e "${_optpreset[0]}" ]] || die 'No presets found in %s' "$_d_presets"
            ;;
        --osrelease)
            shift
            [[ ! -f "$1" ]] && die 'Invalid file -- must be a file'
            _optosrelease="$1"
            ;;
        -t | --builddir)
            shift
            export TMPDIR="$1"
            ;;
        -z | --compress)
            shift
            _optcompress="$1"
            ;;
        -r | --moduleroot)
            shift
            _optmoduleroot="$1"
            ;;
        -D | --hookdir)
            shift
            _d_flag_hooks+="$1/hooks:"
            _d_flag_install+="$1/install:"
            _d_flag_post+="$1/post:"
            ;;
        --)
            shift
            break 2
            ;;
    esac
    shift
done

OPTREST=("$@")

if [[ -t 1 ]] && (( _optcolor )); then
    try_enable_color
fi

# if we get presets and remove flag, skip to preset processing
if (( _optremove && ${#_optpreset[*]} )); then
    map process_preset "${_optpreset[@]}"
    exit
fi

if [[ -n "$_d_flag_hooks" && -n "$_d_flag_install" && -n "$_d_flag_post" ]]; then
    _d_hooks="${_d_flag_hooks%:}"
    _d_install="${_d_flag_install%:}"
    _d_post="${_d_flag_post%:}"
fi

# If we specified --uki but no -g we want to create a temporary initramfs which will be used with the efi executable.
if [[ -n "$_optuki" && -z "$_optgenimg" ]]; then
    tmpfile="$(mktemp -t mkinitcpio.XXXXXX)"
    _tmpfiles+=("$tmpfile")
    _optgenimg="$tmpfile"
fi

# insist that /proc and /dev be mounted (important for chroots)
# NOTE: avoid using mountpoint for this -- look for the paths that we actually
# use in mkinitcpio. Avoids issues like FS#26344.
[[ -e /proc/self/mountinfo ]] || die "/proc must be mounted!"
[[ -e /dev/fd ]] || die "/dev must be mounted!"

# use preset $_optpreset (exits after processing)
if (( ${#_optpreset[*]} )); then
    map process_preset "${_optpreset[@]}"
    exit
fi

KERNELIMAGE='' KERNELDESTINATION=''
if [[ "$KERNELVERSION" != 'none' ]]; then
    # if the "version" is given as a file name, use it without modification,
    # if doesn't exist, resolve_kernver will fail anyway
    if [[ "${KERNELVERSION:0:1}" == '/' ]]; then
        KERNELIMAGE="$KERNELVERSION"
    fi

    KERNELVERSION="$(resolve_kernver "$KERNELVERSION")" || exit 1
    _d_kmoduledir="$_optmoduleroot/lib/modules/$KERNELVERSION"
    [[ -d "$_d_kmoduledir" ]] || die "'$_d_kmoduledir' is not a valid kernel module directory"

    if [[ -z "$KERNELIMAGE" ]]; then
        # search well-known locations for the kernel image
        for img in "$_d_kmoduledir/vmlinuz" "/lib/modules/$KERNELVERSION/vmlinuz"; do
            if [[ -f "$img" ]]; then
                KERNELIMAGE="$img"
                if read -r pkgbase &>/dev/null <"${img%/*}/pkgbase"; then
                    KERNELDESTINATION="/boot/vmlinuz-$pkgbase"
                else
                    KERNELDESTINATION="/boot/vmlinuz-$KERNELVERSION"
                fi
                quiet "located kernel image: '%s'" "$KERNELIMAGE"
                break
            fi
        done
    fi

    if [[ -z "$KERNELIMAGE" ]]; then
        # check version of all kernels in /boot
        for img in /boot/vmlinuz-*; do
            if [[ "$(kver "$img")" == "$KERNELVERSION" ]]; then
                KERNELIMAGE="$img"
                quiet "located kernel image: '%s'" "$KERNELIMAGE"
                break
            fi
        done
    fi

    if [[ -f "$KERNELIMAGE" ]]; then
        [[ -z "$KERNELDESTINATION" ]] && KERNELDESTINATION="$KERNELIMAGE"
    else
        # this is not fatal, initramfs will still be generated but post
        # hooks will not know what kernel image is used
        warning 'Could not find kernel image for version %s' "$KERNELVERSION"
    fi
fi

MODULES_DECOMPRESS="${MODULES_DECOMPRESS:-"yes"}"

_d_workdir="$(initialize_buildroot "$KERNELVERSION" "$_opttargetdir")" || exit 1
BUILDROOT="${_opttargetdir:-$_d_workdir/root}"

# shellcheck disable=SC1091 source=mkinitcpio.conf
. "$_f_config" || die "Failed to read configuration '%s'" "$_f_config"

arrayize_config

# after returning, hooks are populated into the array '_hooks'
# HOOKS should not be referenced from here on
compute_hookset

if (( ${#_hooks[*]} == 0 )); then
    die "Invalid config: No hooks found"
fi

if (( _optshowautomods )); then
    msg "Modules autodetected"
    # shellcheck source=install/autodetect
    PATH="$_d_install" . 'autodetect'
    build
    printf '%s\n' "${!_autodetect_cache[@]}" | sort
    exit 0
fi

if [[ -n "$_optgenimg" ]]; then
    # check for permissions. if the image doesn't already exist,
    # then check the directory
    if [[ ( -e $_optgenimg && ! -w $_optgenimg ) ||
            ( ! -d ${_optgenimg%/*} || ! -w ${_optgenimg%/*} ) ]]; then
        die "Unable to write to '%s'" "$_optgenimg"
    fi

    _optcompress="${_optcompress:-"${COMPRESSION:-zstd}"}"
    if ! type -P "$_optcompress" >/dev/null; then
        warning "Unable to locate compression method: '%s'" "$_optcompress"
        _optcompress='cat'
    fi

    msg "Starting build: '%s'" "$KERNELVERSION"
elif [[ -n "$_opttargetdir" ]]; then
    msg "Starting build: '%s'" "$KERNELVERSION"
else
    msg "Starting dry run: '%s'" "$KERNELVERSION"
fi

# set functrace and trap to catch errors in add_* functions
declare -i _builderrors=0
set -o functrace
trap '(( $? )) && [[ "$FUNCNAME" == add_* ]] && (( ++_builderrors ))' RETURN

preload_builtin_modules

map run_build_hook "${_hooks[@]}" || (( ++_builderrors ))

# process config file
parse_config "$_f_config"

# switch out the error handler to catch all errors
trap -- RETURN
trap '(( ++_builderrors ))' ERR
set -o errtrace

install_modules "${!_modpaths[@]}"

# unset errtrace and trap
set +o functrace
set +o errtrace
trap -- ERR

# this is simply a nice-to-have -- it doesn't matter if it fails.
ldconfig -r "$BUILDROOT" &>/dev/null
# remove /var/cache/ldconfig/aux-cache for reproducability
rm -f -- "$BUILDROOT/var/cache/ldconfig/aux-cache"

# Set umask to create initramfs images and unified kernel images as 600
umask 077

if [[ -n "$_optgenimg" ]]; then
    build_image "$_optgenimg" "$_optcompress" || exit 1
    _generated+=("$_optgenimg")
elif [[ -n "$_opttargetdir" ]]; then
    msg "Build complete."
else
    msg "Dry run complete, use -g IMAGE to generate a real image"
fi

if [[ -n "$_optuki" && -n "$_optgenimg" ]]; then
    build_uki "$_optuki" "$_optgenimg" "$_optcmdline" "$_optosrelease" "$_optsplash" "$_optkernelimage" "$_optuefistub" "${_optmicrocode[@]}" \
        && (( ${#_generated[*]} )) && _generated+=("$_optuki")
fi

if (( ${#_generated[*]} )); then
    run_post_hooks "${_generated[@]}" || (( ++_builderrors ))
fi

exit $(( !!_builderrors ))

# vim: set ft=sh ts=4 sw=4 et:
